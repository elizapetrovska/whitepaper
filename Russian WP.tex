%% Based on the style files for ACL-2015

\documentclass[11pt]{article}
\usepackage[hidelinks]{hyperref}
\usepackage{acl2015}
\usepackage[numbers]{natbib}
\usepackage{fancyhdr}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{mathtext}
\usepackage[T1,T2A]{fontenc}
\usepackage[english,bulgarian,russian,ukrainian]{babel}


\title{The Keep Network:\protect\\A Privacy Layer for Public Blockchains}

\author{Matt Luongo \\
  {\tt mhluongo@gmail.com} \\\And
  Corbin Pon \\
  {\tt corbin.pon@gmail.com} \\}

\date{}

\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}

\lfoot{Draft: \href{https://github.com/keep-network/whitepaper/tree/COMMIT}{COMMIT} - \today}

\begin{document}

\thispagestyle{fancy}

\maketitle

\begin{Резюме}

  Мы представляем кeep, базовый элемент конфиденциальности 
  для разработки смарт-контрактов в паблик блокчейнах, который 
  позволяет безопасное хранение и использование секретной 
  информации, а вместе с этим и вспомогательную  инфраструктуру, 
  в том числе и токены keep.

  Наш последовательный подход к инфраструктуре конфиденциальности 
  может быть перенесен на рынок через публичную сеть Ethereum, 
  а также добавлен и адaптирован к использованию в других 
  паблик блокчейнах и кросс-блокчейнах.

\end{Резюме}

\section{Мотивация}

\subsection{Ирония паблик блокчейнов}

Паблик блокчейны привнесли беспрецедентную прозрачность и 
аудитоспособность в сферу финансовых технологий. 
Записи неизменяемы, верифицируемы и защищены от цензуры.

К сожалению, эти плюсы являются и минусами для многих потенциальных 
пользователей. 

Каждое использование паблик блокчейна в сфере финансов ограничено 
его публичным статусом. Bitcoin позиционировался как более скрытый 
способ оплаты, чем традиционная финансовая система, но те, кто 
знаком с технологией, знают, что, несмотря на то, что он защищён 
от цензуры, он не может быть приватным по определению \cite{bitcoinPrivacy}. 
Разработчики при знакомстве с Ethereum вскоре снижают планку своих 
ожиданий \cite{ethereumStackexchange}— все состояния контракта 
публикуются в блокчейне и могут быть легко прочитаны конкурирующими 
сторонами.

Эти проблемы признаны разработчиками проектов Bitcoin и Ethereum.

Конфиденциальные транзакции \cite{confidentialTransactions}-текущая 
попытка решения проблемы конфиденциальности, а с ней и 
взаимозаменяемости, в Биткойне, с помощью сайдчейнов \cite{confidentialTransactionsElements}. 
Проект Zerocash \cite{zerocash} применил доказательства нулевого 
знания (zero-knowledge proofs) в Биткоине, что привело к созданию 
Zcash \cite{zcash}- криптовалюты, использующей zk-SNARKs для 
обеспечения конфиденциальности транзакций.

Уже в декабре 2014 г., Виталик Бутерин, один из создателей Ethereum, 
исследовал решение этой проблемы при помощи протокола безопасного 
многостороннего вычисления (sMPC) \cite{secretSharingDaos}. Во многих 
недавних публикациях, Бутерин отмечает, что когда он и другие ведут 
переговоры с компаниями о создании приложений на блокчейн, то 
всегда всплывают две основные проблемы - масштабируемость и 
конфиденциальность. \cite{privacyOnTheBlockchain}.

Масштабируемость публичных блокчейнов является препятствием для 
их широкой адаптации. Одни из лучших умов в области криптовалюты \cite{lightning}
\cite{ethereumSharding} \cite{plasma} работают над улучшениями 
в этом направлении. Однако, конфиденциальность не получила должного
внимания, особенно в отношении смарт-контрактов.

Даже базовые виды использования смарт-контрактов, включая 
публикование секретной информации после соблюдения определённых 
критериев, оценку риска при выдаче кредита, и подписание сообщений 
и транзакций, на сегодняшний день невероятно сложно реализовать в 
паблик блокчейнах.

\subsection{Существующие подходы}

На практике, разработчиками были найдены несколько способов для
разработки децентрализованных приложений, использующих приватные 
данные.

\subsubsection{Шаблон хэш-вскрытия}

Распространенный подход, используемый на публичных блокчейнах - 
это хранение личных данных у пользователей приложения. 
Контракты могут получать доступ и управлять хешами пользовательских 
данных, \cite{commitmentScheme},в то время как оригиналы хранятся 
у пользователя до тех пор, пока не будут раскрыты офф-чейн. 
Мы называем это шаблоном хэш-вскрытия (Hash-reveal pattern).

Для многих приложений такой подход удовлетворителен. Ни одна 
централизованная база данных сторонних разработчиков здесь не 
подвергается риску, что создает явное преимущество с точки зрения 
конфиденциальности по отношению к обычным веб-приложениям. 
Распределенное хранение между несколькими пользователями означает, 
что цель для атаки будет рассеяна.

 Однако, есть и существенные недостатки. Шаблон хэш-вскрытия требует, 
 чтобы все пользователи, участвующие в транзакции, были онлайн, 
 осуществляли мониторинг системы, предоставляли конфиденциальные 
 данные в случае необходимости, и сверяли хэши с приватной информацией, 
 предоставленной другими пользователями.

Данные требования делают шаблон хэш-вскрытия недостаточно гибким для 
сложных протоколов, и так же неподходящим для систем, в которых 
участвуют неодушевлённые  стороны, как, например, децентрализованные 
автономные организации(DAO).

\subsubsection{Приватные блокчейны}

Еще один вид решения проблемы конфиденциальности, в основном 
предпринимаемые финансовой индустрией - создание приватных блокчейнов 
или так называемых ”закрытых реестров”.

Эти системы управляются доверенным или полудоверенным способом. Вместо 
того, чтобы использовать proof-of-work или другой механизм консенсуса, 
разработанный с учетом конкурентности в сети, они могут использовать 
системы наподобие RAFT, чтобы достичь согласованности.

Одной из таких систем является система J.P. Morgan Quorum \cite{quorum}- 
форк Ethereum, поддерживающий поддерживающий приватность не только 
смарт-контрактов, но и обмена сообщениями в сети. Другой системой 
является недавно анонсированная Майкрософт система Coco Framework \cite{coco}, 
обеспечивающая конфиденциальность данных поверх существующего 
приватного блокчейна.

Эти системы решают проблемы конфиденциальности, увы, за счет утраты 
многих преимуществ публичного блокчейна - публичной подотчетности, 
защиты от цензуры и общедоступности. 

\subsubsection{Доказательства с нулевым разглашением (Zero-knowledge proofs)}

Одним из самых известных примеров использования zero-knowledge proofs 
для поддержания конфиденциальности на публичных блокчейнах является Zcash \cite{zcash} 

Zero-knowledge proofs позволяют одной доказывающей стороне (рrover), 
убедить в достоверности утверждения другую проверяющую сторону 
(verifier), без выявления содержания информации, использованной для 
доказательства утверждения. Например, доказывающий мог бы показать,
что он обладает доступом к приватному ключу путем зашифровки с
ообщения, выбранного проверяющим. Доказательство может быть легко 
проверено проверяющим при помощи расшифровки сообщения, используя 
паблик ключ. Приватный ключ остается при этом нерассекреченым.

Что касается сферы владения, zero-knowledge proofs могут быть 
использованы какой-либо из сторон для доказательства того, что 
у них есть доступ к средствам, или, в случае Zcash, для 
доказательства майнерам, что транзакция действительна, в соответствии 
с консенсусом сети.

Zero-knowledge proofs могут быть использованы для создания частных 
финансовых систем в паблик блокчейнах. Однако сами по себе они не 
позволяют безопасно передавать личные данные от одной стороны к 
другой и, опять же, требуют всегда находиться онлайн для хэш-вскрытия.

Доказательства с нулевым разглашением - очень мощный криптографический 
инструмент который может быть использован в сочетании с другими 
методами для предоставления безопасного доступа к приватным данным 
и вычислениям \ref{sMPC}

\subsection{Публичное использование, конфиденциальные данные}

Ни один из этих методов не предоставляет удовлетворительное 
решение для построения публично верифицируемого, децентрализованного, 
устойчивого к цензуре приложения, которое будет работать с 
конфиденциальной информацией.

К примеру, данные решения не могут обеспечить разработку контракта, 
раскрывающего конфиденциальные данные в случае возникновения 
разногласий между двумя сторонами, или подписание сообщения, 
верифицирующего контракт офф-чейн (вне основной цепи) или безопасное
шифрование файлов \footnote{Мы рассмотрим темы приложений подробнее 
в разделе \ref{applications}}.

\section{Представляем keeps}

Чтобы решить эту проблему несоответствия между прозрачностью публичных 
блокчейнов и потребностью множества автономных смарт-контрактов в 
конфиденциальных данных, мы представляем вашему вниманию {\em keep}.

Keep - это офф-чейн контейнер для конфиденциальных данных. Keep 
позволяет контрактам управлять и использовать конфиденциальные данные 
без раскрытия этих данных в паблик блокчейне.

\subsection{Операции с хранилищами Keep}

\begin{table*}[t]
  \centering
  \begin{tabular}{|rp{10cm}|}
  \hline
  \multicolumn{2}{|c|}{\textit{Keep operations}} \\
  \textbf{Create:} & $Contract_{owner}$ publishes a creation request,
  including an initial deposit and a public key,
  $K_{Contract_{owner}}$.\\
  \textbf{Accept:} & A keep, $Keep_{accepted}$, publishes one or more
  public keys $K_{Keep_{accepted_i}}$ signalling readiness.\\
  \textbf{Populate:} & $Contract_{owner}$ publishes an initial
  secret on-chain, encrypted in total or in shares by one or more
  $K_{Keep_{accepted_i}}$, or a specification for a secret to be
  generated.\\
  \textbf{Grant:} & $Contract_{owner}$ publishes another contract
  address, $Contract_{delegate}$, and a permission level, $P_{read}$
  or $P_{admin}$.\\
  \textbf{Compute:} & $Contract_{owner}$ or $Contract_{delegate}$
  publishes a function to compute over the secret, $F(S,...)$, as well
  as other arguments to $F$. Initially $F {\in}
  \{f_{identity},f_{rsa},f_{ecdsa}\}$, though additional functions are
  planned.\\
  \textbf{Results:} & $Keep_{accepted}$ publishes the results
  of its computation, either in whole or in part, over one or more
  invocations.\\
  \textbf{Shutdown:} & $Contract_{owner}$ or $Contract_{delegate}$
  with permission $P_{admin}$ publishes a shutdown request.\\
  \hline
\end{tabular}
\end{table*}

Хотя контейнеры keep хранят информацию офф-чейн, их поддержка и 
взаимодействие с контрактами происходит он-чейн. Мы опишем эти он-чейн 
операции с хранилищами Keep. Практическое применение Keep, включая 
гарантии безопасности, описано в разделах \ref{eliminatingRisk} and \ref{keepProviders}.

\subsubsection{Создание и заполнение}

Контракт, $Contract_{owner}$, запрашивает хранилище keep, публикуя запрос 
в блокчейн. Когда хранилище приняло запрос, $Keep_{accepted}$, и завершило 
инициализацию офф-чейн, оно отвечает на данный запрос набором открытых 
ключей, которые запрашивающий контракт может использовать, чтобы 
конфиденциально связываться с хранилищем. 

 Как только хранилище создано, оно может быть заполнено различными способами. 
 Децентрализованные приложения (dApps) могут размещать зашифрованные при 
 помощи паблик ключей кеер конфиденциальные данные на блокчейне, или 
 отправлять данные хранилищу кеер офф-чейн. А так же, keep может 
 само-заполниться псевдослучайными данными.

\subsubsection{Публикация данных он-чейн}

Назначением хранилища keep является вычисление функции на 
основании секретных данных и её публикация на блокчейне.

Сначала хранилища будут поддерживать публикацию секретных 
данных он-чейн либо неизменными, либо зашифрованными при 
помощи публичного ключа, предоставленного владельцем контракта
$Contract_{owner}$. Благодаря этому становится возможной 
функциональность, которой сложно достигнуть в нынешних 
публичных смарт-контрактах, как, например, раскрывающий 
конфиденциальные данные Dead Man's Switch, полезный в различных 
схемах децентрализованного рынка.

Хранилища кеер могут использовать секретные данные множеством 
других способов, включая их использование в качестве основы 
для создания ключа для симметричного шифрования и подписи.

\subsubsection{Управление доступом}

Контракт, владеющий хранилищем кеер $Contract_{owner}$ также 
может предоставлять доступ к хранилищу и другим контрактам.

Может предоставляться доступ для чтения или администрирования, 
позволяя другому контракту i($Contract_{delegate}$) запрашивать 
публикацию содержимого хранилища (read permission, $P_{read}$), 
или предоставлять дальнейший доступ другим контрактам (admin permission, $P_{admin}$). 
Владельцы ($Contract_{owner}$) также могут отзывать собственный доступ. 

Управление доступом дает возможность многосторонней безопасной 
передачи средств на хранение третьему лицу, а также проверки 
и контроля секретного доступа.

\subsubsection{Продолжительность использования}

В зависимости от варианта использования, хранилища keep могут 
быть использованы в течении короткого или длительного периода.
Контракты могут запрашивать закрытие хранилища, а также  должны 
разрешать коллизии с хранилищами, которые неожиданно завершили 
работу (сценарии, которые более подробно описаны в разделе \ref{uptime}.

\section{Устранение риска с третьих сторон} \label{eliminatingRisk}

Мы описали обычный черный ящик для хранения данных офф-чейн. 
Стандартизация этого метода управления секретной информацией 
позволит секретной информации быть купленной, проданной, отправленной 
в публичный блокчейн, но, по сути, не решает проблемы стороннего риска.

Далее мы опишем технику устранения стороннего риска.

\subsection{Безопасное многостороннее вычисление} \label{sMPC}

Безопасное многостороннее вычисление (sMPC) - это тип криптографической 
системы, где вычисление распределяется между многими участниками, 
некоторые из которых могут иметь недобросовестные намерения. Заказчиком 
каждому из участников изначально даётся доступ к части секретной 
информации, над которой он вычисляет функцию. Результаты сообщаются 
заказчику, который может собрать результат воедино. Таким образом, 
никто из участников не будет обладать большей информацией, чем была 
получена ими изначально.

Наглядно sMPC работает следующим образом:

\begin{enumerate}
  \item Заказчик $D$ хочет вычислить функцию $F$ над секретной информацией,
      $S$.
  \item Заказчик выбирает $n$ - ное количество сторон для вычисления, 
  и отправляет каждой часть секретной информации, $s_i$.
  \item Каждая сторона вычисляет функцию через их часть $f_i(s_i)$ и 
  сообщает результат заказчику.
  \item Заказчик соединяет выходы данных так, что
      $G(f_1(s_1),f_2(s_2),...f_n(s_n)) = F(S)$
\end{enumerate}

Части $s_i$ должны быть выбраны таким способом, чтобы разоблачение 
одной части не поставило под угрозу разоблачение секретной 
информации $S$. Распространенным подходом является использование 
схемы распределения секрета Шамира (Shamir's Secret Sharing) \cite{shamir}, 
где детали секрета остаются нераскрытыми перед $n-1$ нечестных сторон. 

Это объяснение справедливо для всех $F$ включая сложение, вычитание 
и умножение на известную константу. Однако, для достижения общих 
вычислений, нам также необходимо надежно умножать секретные данные. 

Умножение привносит то, что в литературе называют «раундами» — общение 
между сторонами, а не только c заказчиком $D$.

Чтобы умножить два секрета, каждая сторона $P_i$ выбранных заказчиком $n$ 
разбивает свою часть информации, $s_i$, на два компонента, $s_{i1}$ и
$s_{i2}$. Сторона умножает эти два компонента, получая в результате
$s_{i'}$. Каждая $P_i$ здесь действует как заказчик среди оставшихся 
сторон, разбивая $s_{i'}$ на $n-1$ частей. 

Каждая $P_i$ теперь может решить свою полученную в раунде умножения 
часть информации, $s'_i$, имея допуск к $n-1$ частям $s_{i'}$.

Благодаря сложению и умножению, sMPC могут надежно и безопасно выполнять 
основные вычисления, но за счёт избыточного взаимодействия между 
вычисляющими сторонами.

\subsection{sMPC и блокчейн}

Первоначально sMPC был разработан в 1982 году \cite{yao1982protocols}, 
но его практическое применение было лимитировано из-за ограничений на 
модель безопасности. Существующие решения sMPC обеспечивают безопасность 
только в случае честности большинства участников. 

Появление блокчейна позволяет надёжно использовать sMPC и при 
неблагоприятных сценариях. Используя блокчейн как не подлежащий 
изменениям реестр, sMPC становится надёжным инструментом даже в случае 
недобросовестности большинства участников \cite{spdz}, а также 
сверх-устойчивым к Sybil-атакам, благодаря требованию токена сети 
(см. раздел \ref{incentivizingProviders}).

По этим причинам блокчейны и sMPC естественным образом сочетаются друг 
с другом. В пространстве смарт-контрактов, sMPC был уже предложен ранее 
как механизм конфиденциальности. 

В 2014 году, Виталик Бутерин дал введение в этот предмет в своей ранней 
статье о конфиденциальности в паблик блокчейне Ethereum \cite{secretSharingDaos}. 
В 2016 году команда из UMD разработала систему HAWK \cite{hawk}, которая 
объединяет публичные и конфиденциальные смарт-контракты с помощью sMPC, 
а также проект Enigma \cite{enigma}, разработанный Массачусетским 
Техническим Институтом, описывает похожую на нашу систему, с более широким 
уклоном на общие конфиденциальные вычисления.

The Keep network will incorporate these ideas into the first
production-ready sMPC system for a public blockchain.

\section{Keep providers} \label{keepProviders}

The Keep network includes a number of different provider types, each
with their own strengths and tradeoffs. The most important provider,
however, is a novel application of secure multi party computation.

\subsection{Simple sMPC}

Simple sMPC keeps are backed by $n$ nodes, each of which maintain a
share of the provided secret, such that the secret can't be
reconstructed without all $n$ nodes colluding.

These keeps can be populated securely by divvying up a secret into
shares via Shamir secret sharing \cite{shamir}, and encrypting each
share with its respective node's public key. The encrypted shares can
then be published to the public blockchain, or communicated off-chain.

The only computation these keeps will run is an implementation of
distributed RSA \cite{mauland2009realizing} on sMPC, used to publish
encrypted data to the blockchain.

\subsection{Signing sMPC}

The next provider will extend the sMPC keep with two new operations-
securely generating pseudorandom numbers, and signing and encrypting
data, using the keep's contents as a key.

In addition to simple pseudorandom numbers, signing keeps will be able
to generate RSA \cite{mauland2009realizing} and Bitcoin
\cite{gennaro2016threshold,coinparty} key pairs, or be populated with
them via secret sharing.

This means signing keeps will be able to sign and secure contract
communications on- and off-chain, as well as sign transactions for
Bitcoin, Ethereum, and other cryptocurrencies.

Finally, signing keeps can act as pRNG oracles, significantly
improving current methods of random number generation on public
blockchains.

\subsection{Future providers}

The off-chain keep pattern is flexible enough to include a variety of
other pluggable providers, each with their own unique benefits.

\subsubsection{Secure hardware}

Keeps backed by secure hardware can be used to lower the cost of
securing private data by verifying that only signed code is run
against privileged data.

Instead of requiring $n$ nodes to safely split a secret, a secret can
be sent to a single node that's properly responded to a challenge,
proving it's running signed code. Not only are fewer nodes required,
but these keeps wouldn't suffer the computation overhead of secure
multi-party computation.

This sort of security is fundamentally weaker than that provided by
secure multi-party computation. If a single secure hardware
manufacturer is compromised, it puts all nodes using that hardware at
risk, shifting the threat model. The cost and benefit of this approach
will depend on the application.

\subsubsection{Private smart contracts}

Unlike related work on systems like Enigma \cite{enigma} or Hawk
\cite{hawk}, which use sMPC to build off-chain and alternative-chain
computation networks for private smart contracts, we've chosen to
restrict the initial sMPC keeps to generating, securing, storing,
encrypting, and transmitting secrets. Such restrictions help to
minimize the attack surface on keeps in a production network.

In later work, sMPC schemes can be used to build more feature-rich
keeps. These keeps will enable complex use cases, like operating
private ledgers against public blockchains, or running third-party
code trustlessly on private data.

\section{Incentivizing keep providers} \label{incentivizingProviders}

Providers need to be incentivized to maintain capacity on the network.
Running and securing keeps should be a profitable way to use excess
compute and storage resources.

Consumer contracts, on the other hand, need keeps that will provide:

\begin{itemize}
  \item High availability
  \item Robustness against data loss
  \item Maintenance of confidentiality
  \item Data integrity
\end{itemize}

\subsection{Paying for keeps}

The best payment structure for keep providers will reward highly
available keeps, and punish poor performance.

<sequence diagram of deposit + per-operation payment>

The two primary costs providers incur are storage and compute, which
map naturally to paying keeps per block and per operation.

Payment per block can be accomplished via a deposit to the managing
contract at the time of keep initialization, metered out over the
lifetime of the keep, and refilled occasionally by the calling
contract. Though this seems like a good fit for payment channels,
minimizing on-chain fees, the security ramifications differ from
typical two-party channels. These differences are discussed further in
the next section.

Payment per operation is simpler. Each request to publish a keep's
contents will require payment of an amount agreed to at the
initialization of a keep.

\subsection{Concerns with uptime and reliability} \label{uptime}

Because availability is vital to using keeps in practice, improper
termination must be disincentivized.

<proper shutdown protocol>

Any keep that doesn't respond properly within a certain block count
threshold to a request will be considered aborted. Aborted keeps will
forfeit all client deposits that have yet to be disbursed. To avoid
skewing client incentives, the deposits that have been earned, but not
yet disbursed, will be burned, and the unearned deposits will be
returned to the client.

Volatility in the crypto currency markets can provide a strong
incentive for a keep provider to improperly terminate a keep. If the
value of the paid currency drops significantly relative to the cost of
running a keep, it's in a provider's best interest to devote their
limited resources to a better-paying client.

To counter this issue, keep providers will need a protocol to
optionally re-negotiate fees for a running keep.

\subsection{Concerns with active attacks}
\label{activeAttacks}

Existing open-source sMPC frameworks, such as VIFF \cite{viff}, are
secure against active attacks in the presence of a ¾ supermajority of
honest nodes. In such an attack, keeps can be forced to return
malformed data, but secrets can't be compromised unless all nodes with
a unique share backing an sMPC keep are colluding- an extremely high
bar for a Sybil attack.

Recent approaches using SPDZ proofs \cite{spdz} anchored on the
blockchain \cite{bitcoinSmpc, blockchainMultipartyComputation} make
such correctness attacks impossible, even if all nodes backing a keep
are compromised. sMPC keeps will publish proofs to the public
blockchain that can be used to verify correctness. The threat of
active attacks is then reduced to disrupting keep availability, rather
than returning malformed data.

We address the issue of network disruption by introducing two
incentives to keep providers, making active attacks on data
availability impractically expensive.

First, keep providers will be required to prove their holdings in a
token native to the system. Significant disruption of the network
should lead to a drop in the value of the token, incentivizing
provider honesty, lest they devalue their holdings. This scheme also
provides resistance to Sybil attacks--- an active attacker would need to
obtain an outsize portion of all tokens locked up by keep providers to
ensure their overwhelming selection backing new keeps.

Second, keep redundancy can be used to further minimize availability
disruptions \cite{blockchainMultipartyComputation}. All nodes can be
required to include a deposit when they publish their results. If
their results can't be verified by the included SPDZ proof, their
deposit is forfeit to competing nodes.

\section{High-level network design}

Deploying sMPC-based privacy on a public blockchain requires
supporting infrastructure. To build a functional privacy network
against Ethereum, our first target blockchain, we'll introduce
components to ensure fair keep node selection, report results, and
incentivize network actors.

\subsection{The Keep network token}

The native network token, \textit{KEEP}, will be required for
providers to participate.

To be chosen to provide a node for a new keep, a provider must lock up
a minimum stake in KEEP tokens, using a shared staking contract.

At any time, a provider can choose to retrieve their stake--- for
example, to liquidate their position. All withdrawals, however, will
be subject to a two-week waiting period to disincentivize providers from
quickly staking and withdrawing their position, which could have
adverse effects on running keeps and fair keep selection.

Requiring a native token, rather than the underlying blockchain's
currency, means providers will suffer from negative externalities in
the presence of malicious behavior (see section \ref{activeAttacks}). This sort
of staking also strengthens the system against Sybil attacks (see section
\ref{fairKeepSelection}).

\subsection{Ensuring fair keep selection}
\label{fairKeepSelection}

Contracts requesting keeps and keep providers need to be matched. An
ideal system would enable price discovery, incentivizing new providers
to join if capacity is low, across different keep types.

This matching problem is a great fit for a market. Unfortunately,
on-chain markets are a difficult problem, prone to complexity, miner
frontrunning, and orderbook manipulation. A clever attacker could
manipulate a market, giving them an unfair advantage to be chosen for
a particular keep. Essentially, a two-sided market would expose the
network to Sybil attacks.

In lieu of a market, we need a fair keep selection mechanism.

\subsubsection{Random beacons}

The best way to select providers for a new keep is with a fair coin
toss. Unfortunately, Ethereum only supports deterministic functions.
Contracts that require a random number often rely on a trusted oracle.

A system is only as decentralized as its most centralized component.
Relying on a trusted third party for such a core function of the
project isn't an acceptable risk.

Instead, we can utilize our keep providers as a decentralized source
of entropy. All staked providers can be required to take part in the
random number generation process.

There are a few design considerations for such a system:
\begin{itemize}
  \item Providers can't be allowed an unfair advantage over each other
      in the node selection process.
  \item Each block on the public chain will require at least one
      random number of sufficient size. Today's Ethereum block time is
      25 seconds, but that will likely change significantly in the
      future. The RNG process needs to be fast enough to support much
      shorter block time, if necessary.
  \item RNG needs to be resilient to node failure. Failure in
      production means no new keeps can be created, so resilience
      to partitions between providers as well as against active denial
      of service attacks is desirable.
  \item While not a hard system requirement, providing the Ethereum
      network with a trusted source of randomness will also be a great
      boon to other projects.
\end{itemize}

Most distributed key generation schemes are too slow or prone to
manipulation to be considered. Any scheme we choose should provide
good performance, regardless of the number of participating providers.
Instead, most generation schemes require rounds of communication
between participants, slowing down the key generation process and
providing a large surface for communication failure.

Fortunately, the Dfinity team has solved these issues with their
random beacon design, based on a concept they call threshold relay
\cite{thresholdRelay}.

\subsubsection{Threshold relay}

\begin{table*}[t]
  \centering
  \begin{tabular}{|rp{10cm}|}
  \hline
  \multicolumn{2}{|c|}{\textit{Iterative threshold signatures for
  randomness on existing chains}} \\
  \textbf{Registration:} & As providers join the network, they
  register with at least one threshold group $G_i$ of all groups $G$,
  generating a share of the group's private key, $s_i$. Threshold groups are
  capped at $c$ members, and may intersect. Groups that have reached
  this maximum size publish their public key to the blockchain. We'll
  designate such groups as $G_{registered}$. \\
  \textbf{Trusted setup:} & A trusted party posts a random value
  $r_0$ to the blockchain as the beacon's first output. \\
  \textbf{Bootstrapping:} & $mod(r_{0}, |G_{registered}|)$ is
  used to select a registered threshold group, $G_i$, from
  $G_{registered}$. $G_i$ signs $r_0$ and publishes the
  result, $r_1 = threshold(r_0, s_{0\rightarrow{t}})$ where
  $s_{0\rightarrow{t}}$ is the minimal shares necessary for the group
  to produce a signature. Note that $threshold(...)$ must be a
  deterministic signature scheme to avoid share withholding attacks
  leading to a biased output. \\
  \textbf{Iteration:} & Each block published on the chain will include
  a signature from $G_{registered}$ of the random value $r_i$. As the
  chain grows, the signing threshold groups will change based on
  provider availability. If any group is non-responsive up to its
  threshold $t$, the group is removed from $G_{registered}$. \\
  \textbf{Failure:} & Each iteration is an opportunity for a
  group to fail to generate a valid signature. If a group $G_i$ fails
  to sign the last iteration's random value, $G_{i+1}$ will be used
  instead. \\
  \hline
\end{tabular}
\end{table*}

This work relies on the idea of threshold secret sharing schemes---secret
sharing schemes that retain confidentiality up to some threshold $t$ of
honest actors.

Threshold signatures are a related idea. A threshold signature is a
signature across $n$ parties that requires some minimum $t$ actively
participating to sign. It's a similar idea to "multi-sig" as deployed
in cryptocurrencies today.

Traditional multi-sig, however, requires a smart contract on the
blockchain to validate each signature and release funds. Threshold
signature schemes actually require a threshold $t$ to construct a
signature at all, removing a layer of complexity and coordination
between parties.

The use of threshold signatures means a number of participating
signers in a signing group can be unavailable, and the signature will
still succeed in the presence of $t$ functioning signers. This
provides some of our beacon's required resilience in the face of
failing or misbehaving nodes.

If threshold signatures sound familiar, it might be because they're a
core functionality keeps provide. For example, a keep signing a
Bitcoin transaction does so using threshold ECDSA.

A threshold relay is a way to chain threshold signatures to create a
random beacon. Participants in a threshold relay form threshold
groups. These groups generate new public keys that identify the group
and correspond to a newly generated threshold private key, split
across the participants.

As providers join the network, they will form threshold groups. These
groups will then sign a piece of random data, initially provided by
early network contributors, to bootstrap the relay. The resulting
signature provides the random data for the next iteration, which can
be verified by the rest of the network participants and rejected if
invalid. Each iteration, a new signing group is chosen by the previous
iteration's random value. As all groups sign the previous iteration's
value, if a signature that's chosen is invalid, the signature from the
next group in line can be chosen instead.

Importantly, the threshold signature scheme needs to be deterministic
to prevent individual shareholders from biasing the signature outcome
in their favor. BLS signatures \cite{BLS} have been used in related
work.

\subsubsection{Keep selection group}

Our threshold relay system will be composed of keep providers seeking
to be chosen to back a new keep, capturing the fees from that keep.

Each block will include a random signature, published by the nominated
keep selection group. Any keeps that require new nodes will have their
providers chosen randomly, using the beacon value from the last block.

In this way, we can ensure fair chances to all staked keep providers,
keeping the cost of a Sybil attack high.

\section{The result registry}

Keeps will offer a number of methods to publish to the public
blockchain. In the case where keeps publish to a smart contract
provided by the keep owner, coordination is simple. In uses that don't
have a natural contract to communicate with, a result registry will be
provided as a default to simplify keep and owner coordination.

\section{Applications}
\label{applications}

\subsection{Dead man switch}

A dead man switch is a device that is automatically activated in case
its owner becomes incapacitated. Keeps enable a particular kind of
dead man switch- publishing a secret, under certain contract
conditions.

Examples of dead man switch applications with keeps include automated
inheritance (``send my beneficiary my private key if I don't check in
quarterly''), arbitration with time limits (``if no decision is made in
10 blocks, publish a shared secret''), as well as protection for
leakers (``publish a key to these insurance files if I don't check
in'').

\subsection{Marketplaces for digital goods}

Buying and selling digital goods on public blockchains today requires
settling off-chain. Keeps make marketplaces for digital goods, like
audio and video files, straightforward.

Without keeps, each transfer of a private digital good requires one or
more hash-reveal constructions on-chain. More complex scenarios
that require escrow, arbitrators, and other parties who might need
access to the transfered digital good will need ${n^2}$ on-chain
transactions to maintain security. They also require each party to be
online to participate.

Keeps obviate always-online requirements, and simplify the hash-reveal
protocol to access management. All keep access is auditable, and
participants can have access to a keep without viewing its contents,
allowing further optimization.

Without an always-online requirement or complex reveal protocols,
keeps can efficiently support services like iTunes on the blockchain.

\subsection{Pseudorandomness oracle}

Since keeps can populate themselves with random data, they can act as
pseudorandomness oracles, improving on currently popular methods
\cite{prngStackexchange}. sMPC and other secure keeps are a good fit for
decentralized lotteries and other games of chance, as well as offering
a building block for other on-chain algorithms that require
tamper-resistant pRNG.

This capability is an important component of advanced keep users, like
decentralized signing.

\subsection{Decentralized signing service}

Signing sMPC keep providers are able to sign messages, including
blockchain transactions, using a generated or provided private key.

For the first time, contracts will be able to assert their identity
off-chain, without requiring the recipient's awareness of blockchain
state.

Consider a decentralized signing service for Bitcoin transactions. The
service can participate in multi-signature transactions, only signing
transactions that follow a strict set of rules, including daily
spending limits and recipient whitelists.

Other uses for such a service include second-factor authentication,
where a contract can answer a challenge-response protocol based on
rules on the blockchain.

\subsection{Custodial wallets and cross-chain trading}

As a special case of a signing service, contracts can use keeps to
generate their own cryptocurrency wallets, taking full custody of any
received funds.

For example, a contract can generate a Bitcoin wallet, and sign
Bitcoin transactions in response to receiving assets on the contract's
native blockchain.

\subsection{Encryption service for blockchain storage}

Services like Filecoin \cite{filecoin} and Storj \cite{storj} are
being built to provide cheap, ubiquitous storage, accessible globally,
via smart contracts and traditional storage interfaces.

These services offer few privacy guarantees by default, leaving the
onus of file encryption on users. Keeps can provide a private bridge
to blockchain storage. By generating an AES key at keep initialization
and providing off-chain data access to the keep, smart contracts can
use keeps to secure files stored on decentralized services.

\subsection{Banking on public blockchains}

As more keep providers are developed, more applications that once
required a private blockchain can be built against public networks.

Traditional finance offers many examples. Consider lending, a basic
service provided by most banks.

There are a number of sensitive variables involved in the lending
process. Borrower credit scores are sensitive; risk assessment is
highly competitive; the terms of a loan aren't typically made public.

Keep providers that execute generic private smart contracts can
protect scores and the risk assessment process, while maintaining
auditability and all other benefits of a public blockchain.

\bibliographystyle{unsrt}
\bibliography{references}{}

\end{document}
