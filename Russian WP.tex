%% Based on the style files for ACL-2015

\documentclass[russian,english,11pt]{article}
\usepackage[hidelinks]{hyperref}
\usepackage{acl2015}
\usepackage[numbers]{natbib}
\usepackage{fancyhdr}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{mathtext}
\usepackage[T1,T2A,OT1]{fontenc} % enable Cyrillic fonts
\usepackage[russian,english]{babel}
\usepackage[utf8]{inputenc} % make weird characters work


\title{The Keep Network:\protect\\A Privacy Layer for Public Blockchains}

\author{Matt Luongo \\
  {\tt mhluongo@gmail.com} \\\And
  Corbin Pon \\
  {\tt corbin.pon@gmail.com} \\}

\date{}

\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}

\lfoot{Draft: \href{https://github.com/keep-network/whitepaper/tree/COMMIT}{COMMIT} - \today}

\begin{document}

\thispagestyle{fancy}

\maketitle

\begin{Резюме}

  Мы представляем кeep, базовый элемент конфиденциальности 
  для разработки смарт-контрактов в паблик блокчейнах, который 
  позволяет безопасное хранение и использование секретной 
  информации, а вместе с этим и вспомогательную  инфраструктуру, 
  в том числе и токены keep.

  Наш последовательный подход к инфраструктуре конфиденциальности 
  может быть представлен на рынке через публичную сеть Ethereum, 
  а также добавлен и адaптирован к использованию в других 
  паблик блокчейнах и кросс-блокчейнах.

\end{Резюме}

\section{Мотивация}

\subsection{Ирония паблик блокчейнов}

Паблик блокчейны привнесли беспрецедентную прозрачность и 
аудитоспособность в сферу финансовых технологий. 
Записи неизменяемы, верифицируемы и защищены от цензуры.

К сожалению, эти плюсы являются и минусами для многих потенциальных 
пользователей. 

Каждый  случай финансового использования паблик блокчейна ограничен 
его публичным статусом. Bitcoin позиционировался как более 
конфиденциальный способ оплаты, чем традиционная финансовая система, 
но те, кто знаком с технологией, знают, что, несмотря на то, что 
он защищён от цензуры, он не может быть конфиденциальным по 
определению \cite{bitcoinPrivacy}. Разработчики при знакомстве с 
Ethereum вскоре снижают планку своих ожиданий \cite{ethereumStackexchange}— 
все состояния контракта публикуются в блокчейне и могут быть легко 
прочитаны конкурирующими сторонами.

Эти проблемы признаны разработчиками проектов Bitcoin и Ethereum.

Конфиденциальные транзакции \cite{confidentialTransactions}-текущая 
попытка решения проблемы конфиденциальности, а с ней и 
взаимозаменяемости, в Биткойне, с помощью сайдчейнов \cite{confidentialTransactionsElements}. 
Проект Zerocash \cite{zerocash} применил "доказательства нулевого 
знания" (zero-knowledge proofs) в Биткоине, что привело к созданию 
Zcash \cite{zcash}- криптовалюты, использующей zk-SNARKs для 
обеспечения конфиденциальности транзакций.

Уже в декабре 2014 г., Виталик Бутерин, один из создателей Ethereum, 
исследовал решение этой проблемы при помощи протокола безопасного 
многостороннего вычисления (sMPC) \cite{secretSharingDaos}. Во многих 
недавних публикациях, Бутерин отмечает, что когда он и другие ведут 
переговоры с компаниями о создании приложений на блокчейн, то 
всегда всплывают две основные проблемы - масштабируемость и 
конфиденциальность. \cite{privacyOnTheBlockchain}.

Масштабируемость публичных блокчейнов является препятствием для 
их широкой адаптации. Одни из лучших умов в области криптовалюты \cite{lightning}
\cite{ethereumSharding} \cite{plasma} работают над улучшениями 
в этом направлении. Однако, конфиденциальность не получила должного
внимания, особенно в отношении смарт-контрактов.

Даже базовые виды использования смарт-контрактов, включая 
публикацию секретной информации после соблюдения определённых 
критериев, оценку риска при выдаче кредита, и подпись сообщений 
и транзакций, на сегодняшний день невероятно сложно реализовать в 
паблик блокчейнах.

\subsection{Существующие подходы}

На практике, разработчиками были найдены несколько способов для
разработки децентрализованных приложений, использующих приватные 
данные.

\subsubsection{Шаблон хэш-вскрытия}

Распространенный подход, используемый на публичных блокчейнах - 
это хранение личных данных у пользователей приложения. 
Контракты могут получать доступ и управлять хешами пользовательских 
данных, \cite{commitmentScheme},в то время как оригиналы хранятся 
у пользователя до тех пор, пока не будут раскрыты офф-чейн. 
Мы называем это шаблоном хэш-вскрытия (Hash-reveal pattern).

Для многих приложений такой подход удовлетворителен. Он дает явное 
преимущество в конфиденциальности по отношению к обычным 
веб-приложениям так как ни одна централизованная база данных 
сторонних разработчиков здесь не подвергается риску. Распределенное 
хранение между несколькими пользователями означает, 
что цель для атаки будет рассеяна.

Однако, у этого подхода есть и существенные недостатки. Шаблон 
хэш-вскрытия требует, чтобы все пользователи, участвующие в 
транзакции, были онлайн, осуществляли мониторинг системы, предоставляли 
конфиденциальные данные в случае необходимости, и сверяли хэши с 
приватной информацией, предоставленной другими пользователями.

Данные требования делают шаблон хэш-вскрытия недостаточно гибким для 
сложных протоколов, и так же неподходящим для систем, в которых 
участвуют неодушевлённые  стороны, как, например, децентрализованные 
автономные организации (DAO).

\subsubsection{Приватные блокчейны}

Еще одним видом решения проблемы конфиденциальности, в основном 
используемый финансовой индустрией, является создание приватных 
блокчейнов или так называемых ”закрытых реестров”.

Эти системы работают  в доверенном  или полудоверенном  режиме. Вместо 
того, чтобы использовать proof-of-work или другой механизм консенсуса, 
разработанный с учетом конкурентности в сети, они могут использовать 
системы наподобие RAFT, чтобы достичь согласованности.

Одной из таких систем является система J.P. Morgan Quorum \cite{quorum}- 
форк Ethereum, поддерживающий поддерживающий приватность не только 
смарт-контрактов, но и обмена сообщениями в сети. Другой системой 
является недавно анонсированная Майкрософт система Coco Framework \cite{coco}, 
обеспечивающая конфиденциальность данных поверх существующего 
приватного блокчейна.

Эти системы решают проблемы конфиденциальности, увы, за счет утраты 
многих преимуществ публичного блокчейна - публичной подотчетности, 
защиты от цензуры и общедоступности. 

\subsubsection{Доказательства с нулевым разглашением (Zero-knowledge proofs)}

Одним из самых известных примеров использования zero-knowledge proofs 
для поддержания конфиденциальности на публичных блокчейнах является Zcash \cite{zcash} 

Zero-knowledge proofs позволяют одной доказывающей стороне (рrover), 
убедить в достоверности утверждения другую проверяющую сторону 
(verifier), без выявления содержания информации, использованной для 
доказательства утверждения. Например, доказывающий мог бы показать,
что он обладает доступом к приватному ключу путем зашифровки с
ообщения, выбранного проверяющим. Доказательство может быть легко 
проверено проверяющим при помощи расшифровки сообщения, используя 
паблик ключ. Приватный ключ остается при этом нерассекреченым.

Что касается сферы владения, zero-knowledge proofs могут быть 
использованы какой-либо из сторон для доказательства того, что 
у них есть доступ к средствам, или, в случае Zcash, для 
доказательства майнерам, что транзакция действительна, в соответствии 
с консенсусом сети.

Zero-knowledge proofs могут быть использованы для создания частных 
финансовых систем в паблик блокчейнах. Однако сами по себе они не 
позволяют безопасно передавать личные данные от одной стороны к 
другой и, опять же, требуют всегда находиться онлайн для хэш-вскрытия.

Доказательства с нулевым разглашением - очень мощный криптографический 
инструмент который может быть использован в сочетании с другими 
методами для предоставления безопасного доступа к приватным данным 
и вычислениям \ref{sMPC}

\subsection{Публичное использование, конфиденциальные данные}

Ни один из этих методов не предоставляет удовлетворительное 
решение для построения публично верифицируемого, децентрализованного, 
устойчивого к цензуре приложения, которое будет работать с 
конфиденциальной информацией.

К примеру, данные решения не могут обеспечить разработку контракта, 
раскрывающего конфиденциальные данные в случае возникновения 
разногласий между двумя сторонами, или подписание сообщения, 
верифицирующего контракт офф-чейн (вне основной цепи) или безопасное
шифрование файлов \footnote{Мы рассмотрим темы приложений подробнее 
в разделе \ref{applications}}.

\section{Представляем keeps}

Чтобы решить эту проблему несоответствия между прозрачностью публичных 
блокчейнов и потребностью множества автономных смарт-контрактов в 
конфиденциальных данных, мы представляем вашему вниманию {\em keep}.

Keep - это офф-чейн контейнер для конфиденциальных данных. Keep 
позволяет контрактам управлять и использовать конфиденциальные данные 
без раскрытия этих данных в паблик блокчейне.

\subsection{Операции с хранилищами Keep}

\begin{table*}[t]
  \centering
  \begin{tabular}{|rp{10cm}|}
  \hline
  \multicolumn{2}{|c|}{\textit{Keep operations}} \\
  \textbf{Create:} & $Contract_{owner}$ publishes a creation request,
  including an initial deposit and a public key,
  $K_{Contract_{owner}}$.\\
  \textbf{Accept:} & A keep, $Keep_{accepted}$, publishes one or more
  public keys $K_{Keep_{accepted_i}}$ signalling readiness.\\
  \textbf{Populate:} & $Contract_{owner}$ publishes an initial
  secret on-chain, encrypted in total or in shares by one or more
  $K_{Keep_{accepted_i}}$, or a specification for a secret to be
  generated.\\
  \textbf{Grant:} & $Contract_{owner}$ publishes another contract
  address, $Contract_{delegate}$, and a permission level, $P_{read}$
  or $P_{admin}$.\\
  \textbf{Compute:} & $Contract_{owner}$ or $Contract_{delegate}$
  publishes a function to compute over the secret, $F(S,...)$, as well
  as other arguments to $F$. Initially $F {\in}
  \{f_{identity},f_{rsa},f_{ecdsa}\}$, though additional functions are
  planned.\\
  \textbf{Results:} & $Keep_{accepted}$ publishes the results
  of its computation, either in whole or in part, over one or more
  invocations.\\
  \textbf{Shutdown:} & $Contract_{owner}$ or $Contract_{delegate}$
  with permission $P_{admin}$ publishes a shutdown request.\\
  \hline
\end{tabular}
\end{table*}

Хотя контейнеры keep хранят информацию офф-чейн, их поддержка и 
взаимодействие с контрактами происходит он-чейн. Мы опишем эти он-чейн 
операции с хранилищами Keep. Практическое применение Keep, включая 
гарантии безопасности, описано в разделах \ref{eliminatingRisk} and \ref{keepProviders}.

\subsubsection{Создание и заполнение}

Контракт, $Contract_{owner}$, запрашивает хранилище keep, публикуя запрос 
в блокчейн. Когда хранилище приняло запрос, $Keep_{accepted}$, и завершило 
инициализацию офф-чейн, оно отвечает на данный запрос набором открытых 
ключей, которые запрашивающий контракт может использовать, чтобы 
конфиденциально связываться с хранилищем. 

 Как только хранилище создано, оно может быть заполнено различными способами. 
 Децентрализованные приложения (dApps) могут размещать зашифрованные при 
 помощи паблик ключей кеер конфиденциальные данные на блокчейне, или 
 отправлять данные хранилищу кеер офф-чейн. А так же, keep может 
 само-заполниться псевдослучайными данными.

\subsubsection{Публикация данных он-чейн}

Назначением хранилища keep является вычисление функции на 
основании секретных данных и её публикация на блокчейне.

Сначала хранилища будут поддерживать публикацию секретных 
данных он-чейн либо неизменными, либо зашифрованными при 
помощи публичного ключа, предоставленного владельцем контракта
$Contract_{owner}$. Благодаря этому становится возможной 
функциональность, которой сложно достигнуть в нынешних 
публичных смарт-контрактах, как, например, раскрывающий 
конфиденциальные данные Dead Man's Switch, полезный в различных 
схемах децентрализованного рынка.

Хранилища кеер могут использовать секретные данные множеством 
других способов, включая их использование в качестве основы 
для создания ключа для симметричного шифрования и подписи.

\subsubsection{Управление доступом}

Контракт, владеющий хранилищем кеер $Contract_{owner}$ также 
может предоставлять доступ к хранилищу и другим контрактам.

Может предоставляться доступ для чтения или администрирования, 
позволяя другому контракту i($Contract_{delegate}$) запрашивать 
публикацию содержимого хранилища (read permission, $P_{read}$), 
или предоставлять дальнейший доступ другим контрактам (admin permission, $P_{admin}$). 
Владельцы ($Contract_{owner}$) также могут отзывать собственный доступ. 

Управление доступом дает возможность многосторонней безопасной 
передачи средств на хранение третьему лицу, а также проверки 
и контроля секретного доступа.

\subsubsection{Продолжительность использования}

В зависимости от варианта использования, хранилища keep могут 
быть использованы в течении короткого или длительного периода.
Контракты могут запрашивать закрытие хранилища, а также  должны 
разрешать коллизии с хранилищами, которые неожиданно завершили 
работу (сценарии, которые более подробно описаны в разделе \ref{uptime}.

\section{Устранение риска с третьих сторон} \label{eliminatingRisk}

Мы описали обычный черный ящик для хранения данных офф-чейн. 
Стандартизация этого метода управления секретной информацией 
позволит секретной информации быть купленной, проданной, отправленной 
в публичный блокчейн, но, по сути, не решает проблемы стороннего риска.

Далее мы опишем технику устранения стороннего риска.

\subsection{Безопасное многостороннее вычисление} \label{sMPC}

Безопасное многостороннее вычисление (sMPC) - это тип криптографической 
системы, где вычисление распределяется между многими участниками, 
некоторые из которых могут иметь недобросовестные намерения. Заказчиком 
каждому из участников изначально даётся доступ к части секретной 
информации, над которой он вычисляет функцию. Результаты сообщаются 
заказчику, который может собрать результат воедино. Таким образом, 
никто из участников не будет обладать большей информацией, чем была 
получена ими изначально.

Наглядно sMPC работает следующим образом:

\begin{enumerate}
  \item Заказчик $D$ хочет вычислить функцию $F$ над секретной информацией,
      $S$.
  \item Заказчик выбирает $n$ - ное количество сторон для вычисления, 
  и отправляет каждой часть секретной информации, $s_i$.
  \item Каждая сторона вычисляет функцию через их часть $f_i(s_i)$ и 
  сообщает результат заказчику.
  \item Заказчик соединяет выходы данных так, что
      $G(f_1(s_1),f_2(s_2),...f_n(s_n)) = F(S)$
\end{enumerate}

Части $s_i$ должны быть выбраны таким способом, чтобы разоблачение 
одной части не поставило под угрозу разоблачение секретной 
информации $S$. Распространенным подходом является использование 
схемы распределения секрета Шамира (Shamir's Secret Sharing) \cite{shamir}, 
где детали секрета остаются нераскрытыми перед $n-1$ нечестных сторон. 

Это объяснение справедливо для всех $F$ включая сложение, вычитание 
и умножение на известную константу. Однако, для достижения общих 
вычислений, нам также необходимо надежно умножать секретные данные. 

Умножение привносит то, что в литературе называют «раундами» — общение 
между сторонами, а не только c заказчиком $D$.

Чтобы умножить два секрета, каждая сторона $P_i$ выбранных заказчиком $n$ 
разбивает свою часть информации, $s_i$, на два компонента, $s_{i1}$ и
$s_{i2}$. Сторона умножает эти два компонента, получая в результате
$s_{i'}$. Каждая $P_i$ здесь действует как заказчик среди оставшихся 
сторон, разбивая $s_{i'}$ на $n-1$ частей. 

Каждая $P_i$ теперь может решить свою полученную в раунде умножения 
часть информации, $s'_i$, имея допуск к $n-1$ частям $s_{i'}$.

Благодаря сложению и умножению, sMPC могут надежно и безопасно выполнять 
основные вычисления, но за счёт избыточного взаимодействия между 
вычисляющими сторонами.

\subsection{sMPC и блокчейн}

Первоначально sMPC был разработан в 1982 году \cite{yao1982protocols}, 
но его практическое применение было лимитировано из-за ограничений на 
модель безопасности. Существующие решения sMPC обеспечивают безопасность 
только в случае честности большинства участников. 

Появление блокчейна позволяет надёжно использовать sMPC и при 
неблагоприятных сценариях. Используя блокчейн как не подлежащий 
изменениям реестр, sMPC становится надёжным инструментом даже в случае 
недобросовестности большинства участников \cite{spdz}, а также 
сверх-устойчивым к Sybil-атакам, благодаря требованию токена сети 
(см. раздел \ref{incentivizingProviders}).

По этим причинам блокчейны и sMPC естественным образом сочетаются друг 
с другом. В пространстве смарт-контрактов, sMPC был уже предложен ранее 
как механизм конфиденциальности. 

В 2014 году, Виталик Бутерин дал введение в этот предмет в своей ранней 
статье о конфиденциальности в паблик блокчейне Ethereum \cite{secretSharingDaos}. 
В 2016 году команда из UMD разработала систему HAWK \cite{hawk}, которая 
объединяет публичные и конфиденциальные смарт-контракты с помощью sMPC, 
а также проект Enigma \cite{enigma}, разработанный Массачусетским 
Техническим Институтом, описывает похожую на нашу систему, с более широким 
уклоном на общие конфиденциальные вычисления.

Keep network соединяет эти идеи в первую готовую к использованию систему 
sMPC для паблик блокчейнов.

\section{Провайдеры Keep} \label{keepProviders}

Сеть Keep включает различные виды провайдеров, каждый из которых имеет 
как сильные стороны, так и недостатки. Однако, самым важным провайдером 
является инновационное применение  sMPC.

\subsection{Простой sMPC}

За простым sMPC хранилищем кeep стоит $n$ - ное количество нод, каждая 
из которых отвечает за часть секретной информации, и эта информация 
не может быть восстановлена без вовлечения всех  $n$ нод.

Эти хранилища могут быть безопасно заполнены путём разделения 
секретной информации на части, используя схему разделения секрета 
Шамира \cite{shamir}, и шифруя каждую часть, используя публичный ключ 
соответствующей ноды. Затем, зашифрованные части могут быть опубликованы 
в паблик блокчейне или можно с ними связываться офф-чейн. 

Единственное вычисление, которые эти хранилища будут проводить — это 
распределенный RSA на sMPC, используемый для публикации зашифрованных 
данных в блокчейн.

\subsection{Подписывающие sMPC}

Следующий провайдер внесёт в sMPC хранилище кеер две новые операции — 
безопасное генерирование псевдослучайных чисел, и подпись и шифрование
данных, используя содержимое хранилища keep в качестве ключа.

В дополнение к простым псевдослучайным числам, подписывающие хранилища 
кеер смогут генерировать пары ключей RSA \cite{mauland2009realizing} 
и Bitcoin \cite{gennaro2016threshold,coinparty}, или заполняться 
ими через схему распределения секретной информации.

Это означает, что подписывающиеся хранилища кеер смогут подписывать и
обеспечивать безопасную передачу контрактов он-чейн и офф-чейн, и так 
же подписывать транзакции Bitcoin, Ethereum и других криптовалют.

И, наконец, подписывающие хранилища keep смогут действовать как pRNG 
оракулы, значительно улучшая тем самым существующие методы генерации 
случайных чисел на паблик блокчейнах.

\subsection{Будущие провайдеры}

Офф-чейн шаблон keep достаточно гибок, чтобы включить в себя различные 
виды других подсоединяемых провайдеров, и каждый имеет свои уникальные 
плюсы. 

\subsubsection{Безопасное аппаратное обеспечение}

Кеер, поддерживаемые безопасным аппаратным обеспечением, могут быть 
использованы для уменьшения стоимости обеспечения безопасности 
конфиденциальных данных путем проверки того, что для привилегированных 
данных используется только подписанный код.

Вместо требования безопасного разделения секрета между n - ным 
количеством нод, секретная информация может быть отправлена одной ноде, 
которая должным образом ответила на вызов, доказав, что исполняет 
подписанный код. В таком случае требуется меньшее количество нод, a 
так же эти хранилища не будут страдать от вычислительных издержек sMPC 
из-за наложения коммуникации между вычисляющими сторонами.
  
Такой вид безопасности существенно слабее, чем тот, что предоставляет sMPC. 
Если один безопасный производитель аппаратного обеспечения взломан, он 
ставит все ноды, использующие это оборудование, под угрозу, смещая модель 
угрозы. Стоимость и преимущества этого подхода будут зависеть от вида его 
использования.

\subsubsection{Частные смарт-контракты}

В отличии от похожих работ над такими системами, как Enigma \cite{enigma} 
или Hawk \cite{hawk}, которые используют sMPC для построения 
вычислительных сетей на основе офф-чейн технологии или технологии 
альтернативных чейн для частных смарт-контрактов, мы решили ограничить 
функции первоначальных sMPC хранилищ keep до обеспечения безопасности, 
генерирования, хранения, шифровки и передачи секретной информации. Такие 
ограничения помогают свести к минимуму количество уязвимых мест для атаки 
на хранилище в рабочей сети.

В дальнейшей работе, схемы sMPC могут быть использованы для создания 
хранилищ кеер с более расширенными функциями. Такие хранилища сделают 
возможными более сложные варианты использования, как например, 
управление приватными реестрами через публичные блокчейны или 
бездоверительное исполнение кода третьей стороны над приватными данными.


\section{Экономическое мотивировсание провайдеров} \label{incentivizingProviders}

Провайдеры должны быть экономически мотивированы, чтобы обеспечить 
высокую производительность сети. Управление хранилищами и обеспечение 
их безопасности должно быть выгодно, учитывая использование избыточных 
вычислительных ресурсов и ресурсов хранения.  

 В то же время, контрактам потребителя нужны кеер, предоставляющие следующие
 условия:

\begin{itemize}
  \item Высокую доступность
  \item Устойчивость к потере данных
  \item Обеспечение конфиденциальности
  \item Целостность (верность) данных
\end{itemize}

\subsection{Плата за хранилища}

Оптимальная структура оплаты для провайдеров keep будет вознаграждать 
широкодоступные хранилища и наказывать хранилища с низкой 
производительностью.

<sequence diagram of deposit + per-operation payment>

Двумя основными затратами для провайдера являются хранение и вычисление, 
что привело к логичному решению: хранилища кеер берут оплату за каждый 
блок и за операцию.

Плата за блок может осуществляться путем внесения депозита в управляющий 
контракт во время инициализации кеер, периодически измеряема в течении 
срока хранения и повторно пополняема по мере необходимости запрашивающим 
смарт-контрактом. Несмотря на то, что это кажется отличной возможностью 
для использования платежных каналов, сведя к минимуму он-чейн комиссии, 
методы обеспечения безопасности здесь отличаются от типичных двухсторонних 
каналов. Эти различия обсуждаются подробнее в следующем разделе.

Оплата за операцию осуществляется проще. В каждом запросе о публикации 
содержимого кeep потребуется оплата суммы, согласованной при инициализации 
хранилища.

\subsection{Опасения насчёт процесса непрерывной работы и надежности} \label{uptime}

Поскольку постоянная доступность критически необходима для практического 
использования хранилищ keep, внезапно прерванная работа должна быть 
экономически наказуема.

<proper shutdown protocol>

Работа любого хранилища кеер, которое не отвечает должным образом в 
течении определенного количества блоков, будет прервана. Прерванные 
keep будут лишены всех депозитов клиентов, которые еще не выплачены. 
To avoid skewing client incentives, the deposits that have been earned, 
but not yet disbursed, will be burned, and the unearned deposits will be
returned to the client.

Для провайдера кеер, волатильность на криптовалютных рынках может стать 
сильным мотивирующим фактором прервать работу хранилища. Если стоимость 
уплаченной валюты значительно снижается по сравнению с затратами на 
управление хранилищем, в интересах провайдера становится выделять свои 
ограниченные ресурсы на обслуживание клиентов, которые готовы заплатить 
больше.

Чтобы противостоять этой проблеме, провайдерам кеер потребуется протокол 
для выборочного пересмотра платы за обслуживание активного хранилища.

\subsection{Опасения относительно активных атак}
\label{activeAttacks}

Существующие работы sMPC открытого доступа, такие как VIFF \cite{viff}, 
являются надёжными в случае активных атак только при условии, 
что большинство нод добросовестны.
В таких атаках, хранилища могут быть принуждены выдать неверно 
сформулированные данные, но секретная информация может быть 
скомпрометирована только в случае если все ноды, имеющие свою долю 
секретной информации, поддерживающие хранилища sMPC, сговорятся, 
что крайне маловерятно, следовательно, это делает атаки Sybil 
практически невозможными.

Недавние решения с использованием доказательств SPDZ \cite{spdz} 
закрепленных на блокчейне \cite{bitcoinSmpc, blockchainMultipartyComputation} 
елают подобные атаки невозможными, даже если все вовлеченные ноды 
keep скомпрометированы. Хранилища sMPC будут публиковать 
доказательства в паблик блокчейн, которые могут быть использованы 
для подтверждения истинности. Угроза активных атак в таком случае 
сводится только лишь к нарушению статуса доступности хранилищ в 
сети, а не к выдаче неверных данных.

Мы решаем проблему разрывa соединения сети, внедряя два 
экономических стимула для  провайдеров, делая тем самым 
активные атаки на доступность данных дорогостоящими, и, тем 
самым, непрактичными.

Итак, первый стимул -  провайдеры должны будут доказать 
наличие денежного запаса в валюте токена системы. Значительное 
нарушение сети приведёт к снижению стоимости токена, и это 
стимулирует честность провайдеров, иначе их собственные запасы 
обесценятся. Эта схема также обеспечивает устойчивость к атакам 
Sybil, т.к. атакующему нужно будет сначала приобрести часть 
токенов, превышающую ту, что заморожена провайдерами кеер, 
чтобы обеспечить себе их выбор для поддержки новых хранилищ. 

Во-вторых, избыток хранилищ может быть использован во благо 
дальнейшей минимизации сбоев доступности сети \cite{blockchainMultipartyComputation}. 
Все ноды могут быть обязаны внести депозит при публикации 
результатов. Если подлинность их результатов не может быть 
доказана с помощью включённого в процесс SPDZ, они лишаются 
депозита  и он распределяется между конкурирующими нодами.

\section{Общее описание дизайна сети}

Установка системы конфиденциальности на основе sMPC на 
паблик блокчейне нуждается в поддерживающей инфраструктуре. 
Чтобы создать функционирующую частную сеть на основе Ethereum-
блокчейна, на который пал наш первый выбор, мы внесём в него 
компоненты для обеспечения справедливого выбора нод хранилища, 
отчётов результатов и экономического стимулирования участников 
сети.

\subsection{Токен сети Кеер}

Для участия провайдерам потребуется собственный токен сети, 
 \textit{KEEP}

Чтобы быть выбранным для предоставления ноды для нового хранилища, 
поставщик должен заморозить минимальное требуемое системой 
количество токенов KEEP, с помощью совместного стэйкинг контракта.

В любое время провайдер может принять решение извлечь свою долю- 
обналичить, к примеру. Но такие решения будут подвергнуты 
двухнедельному периоду ожидания, чтобы не поощрять провайдеров 
на мгновенное снятие с позиции стейкинга, т.к. это может оказать 
неблагоприятное воздействие на ход работы и справедливое 
распределение выбора хранилищ.

Требование использования собственного токена сети вместо валюты 
используемого блокчейна означает, что провайдеры будут испытывать 
на себе негативные эффекты внешних факторов в случае 
неблагосовестного поведения (см. раздел \ref{activeAttacks}). 
Это также поможет сделать сеть гораздо более устойчивой к атакам 
Sybil (см. раздел \ref{fairKeepSelection}).

\subsection{Обеспечение справедливого распределения выбора хранилищ}
\label{fairKeepSelection}

Контракты, запрашивающие хранилища и провайдеры хранилища, должны 
быть корректно соединены. В идеале, система позволила бы 
устанавливать цены, стимулируя новых провайдеров разных типов 
хранилищ к присоединению, если загруженность невелика.

Эта проблема соединения хранилищ и провайдеров прекрасно подходит 
для рынка. К сожалению, он-чейн рынки представляют собой сложную 
проблему. Они комплексны, подвержены атакам майнеров 
(miner frontrunning), и манипуляциям с ценами и заказами. 
  
Умный атакующий может манипулировать рынком, несправедливо отдавая 
преимущество быть выбранным определенному хранилищу. Рынок, на 
котором заявки подают и покупатели и продавцы, будет подвергать 
сеть Sybil-атакам.
  
Вместо рынка нам нужен справедливый механизм распределения выбора 
хранилища.

\subsubsection{Случайные маячки}

Лучший способ выбора провайдера для нового хранилища —  случайность. 
К сожалению, Ethereum поддерживает только детерминированные функции. 
Контракты, нуждающиеся в случайном числе, часто полагаются на услуги 
доверенного оракула.

Система децентрализована настолько, насколько централизован её 
наибольший компонент. Опираться на доверенную третью сторону - 
это неприемлемый риск для основной функции проекта.
  
Вместо этого мы можем использовать наших провайдеров как 
децентрализованный источник энтропии. Все провайдеры, заперевшие 
свой депозит для стейкинга, могут учавствовать в процессе 
генерации случайных чисел.
  
Для дизайна такой системы существует несколько условий:

\begin{itemize}
\item Провайдеры не должны иметь никаких преимуществ перед друг 
другом в процессе выбора ноды.
\item Для каждого блока на паблик блокчейне будет необходимо 
хотя бы одно случайное число достаточного размера.
На сегодняшний день время блока Ethereum составляет 25 секунд, 
но этот показатель, скорее всего, значительно изменится в будущем. 
Процесс RNG должен быть достаточно быстрым, чтобы при необходимости 
поддерживать гораздо более короткое время блока.
\item RNG должен быть устойчивым к сбоям в нодах, т.к. тогда 
новые хранилища не могут быть созданы. Поэтому желательна 
устойчивость к обрывам соединений между провайдерами, а также к 
активным DoS-атакам.
\item Хоть это и не обязательное усовершенствование, но добавление 
в сеть Ethereum механизм генерации случайных чисел также поможет 
многим другим проектам.
\end{itemize}

Most distributed key generation schemes are too slow or prone to
manipulation to be considered. Any scheme we choose should provide
good performance, regardless of the number of participating providers.
Instead, most generation schemes require rounds of communication
between participants, slowing down the key generation process and
providing a large surface for communication failure.

Fortunately, the Dfinity team has solved these issues with their
random beacon design, based on a concept they call threshold relay
\cite{thresholdRelay}.

\subsubsection{Threshold relay}

\begin{table*}[t]
  \centering
  \begin{tabular}{|rp{10cm}|}
  \hline
  \multicolumn{2}{|c|}{\textit{Iterative threshold signatures for
  randomness on existing chains}} \\
  \textbf{Registration:} & As providers join the network, they
  register with at least one threshold group $G_i$ of all groups $G$,
  generating a share of the group's private key, $s_i$. Threshold groups are
  capped at $c$ members, and may intersect. Groups that have reached
  this maximum size publish their public key to the blockchain. We'll
  designate such groups as $G_{registered}$. \\
  \textbf{Trusted setup:} & A trusted party posts a random value
  $r_0$ to the blockchain as the beacon's first output. \\
  \textbf{Bootstrapping:} & $mod(r_{0}, |G_{registered}|)$ is
  used to select a registered threshold group, $G_i$, from
  $G_{registered}$. $G_i$ signs $r_0$ and publishes the
  result, $r_1 = threshold(r_0, s_{0\rightarrow{t}})$ where
  $s_{0\rightarrow{t}}$ is the minimal shares necessary for the group
  to produce a signature. Note that $threshold(...)$ must be a
  deterministic signature scheme to avoid share withholding attacks
  leading to a biased output. \\
  \textbf{Iteration:} & Each block published on the chain will include
  a signature from $G_{registered}$ of the random value $r_i$. As the
  chain grows, the signing threshold groups will change based on
  provider availability. If any group is non-responsive up to its
  threshold $t$, the group is removed from $G_{registered}$. \\
  \textbf{Failure:} & Each iteration is an opportunity for a
  group to fail to generate a valid signature. If a group $G_i$ fails
  to sign the last iteration's random value, $G_{i+1}$ will be used
  instead. \\
  \hline
\end{tabular}
\end{table*}

This work relies on the idea of threshold secret sharing schemes---secret
sharing schemes that retain confidentiality up to some threshold $t$ of
honest actors.

Threshold signatures are a related idea. A threshold signature is a
signature across $n$ parties that requires some minimum $t$ actively
participating to sign. It's a similar idea to "multi-sig" as deployed
in cryptocurrencies today.

Traditional multi-sig, however, requires a smart contract on the
blockchain to validate each signature and release funds. Threshold
signature schemes actually require a threshold $t$ to construct a
signature at all, removing a layer of complexity and coordination
between parties.

The use of threshold signatures means a number of participating
signers in a signing group can be unavailable, and the signature will
still succeed in the presence of $t$ functioning signers. This
provides some of our beacon's required resilience in the face of
failing or misbehaving nodes.

If threshold signatures sound familiar, it might be because they're a
core functionality keeps provide. For example, a keep signing a
Bitcoin transaction does so using threshold ECDSA.

A threshold relay is a way to chain threshold signatures to create a
random beacon. Participants in a threshold relay form threshold
groups. These groups generate new public keys that identify the group
and correspond to a newly generated threshold private key, split
across the participants.

As providers join the network, they will form threshold groups. These
groups will then sign a piece of random data, initially provided by
early network contributors, to bootstrap the relay. The resulting
signature provides the random data for the next iteration, which can
be verified by the rest of the network participants and rejected if
invalid. Each iteration, a new signing group is chosen by the previous
iteration's random value. As all groups sign the previous iteration's
value, if a signature that's chosen is invalid, the signature from the
next group in line can be chosen instead.

Importantly, the threshold signature scheme needs to be deterministic
to prevent individual shareholders from biasing the signature outcome
in their favor. BLS signatures \cite{BLS} have been used in related
work.

\subsubsection{Keep selection group}

Our threshold relay system will be composed of keep providers seeking
to be chosen to back a new keep, capturing the fees from that keep.

Each block will include a random signature, published by the nominated
keep selection group. Any keeps that require new nodes will have their
providers chosen randomly, using the beacon value from the last block.

In this way, we can ensure fair chances to all staked keep providers,
keeping the cost of a Sybil attack high.

\section{The result registry}

Keeps will offer a number of methods to publish to the public
blockchain. In the case where keeps publish to a smart contract
provided by the keep owner, coordination is simple. In uses that don't
have a natural contract to communicate with, a result registry will be
provided as a default to simplify keep and owner coordination.

\section{Applications}
\label{applications}

\subsection{Dead man switch}

A dead man switch is a device that is automatically activated in case
its owner becomes incapacitated. Keeps enable a particular kind of
dead man switch- publishing a secret, under certain contract
conditions.

Examples of dead man switch applications with keeps include automated
inheritance (``send my beneficiary my private key if I don't check in
quarterly''), arbitration with time limits (``if no decision is made in
10 blocks, publish a shared secret''), as well as protection for
leakers (``publish a key to these insurance files if I don't check
in'').

\subsection{Marketplaces for digital goods}

Buying and selling digital goods on public blockchains today requires
settling off-chain. Keeps make marketplaces for digital goods, like
audio and video files, straightforward.

Without keeps, each transfer of a private digital good requires one or
more hash-reveal constructions on-chain. More complex scenarios
that require escrow, arbitrators, and other parties who might need
access to the transfered digital good will need ${n^2}$ on-chain
transactions to maintain security. They also require each party to be
online to participate.

Keeps obviate always-online requirements, and simplify the hash-reveal
protocol to access management. All keep access is auditable, and
participants can have access to a keep without viewing its contents,
allowing further optimization.

Without an always-online requirement or complex reveal protocols,
keeps can efficiently support services like iTunes on the blockchain.

\subsection{Pseudorandomness oracle}

Since keeps can populate themselves with random data, they can act as
pseudorandomness oracles, improving on currently popular methods
\cite{prngStackexchange}. sMPC and other secure keeps are a good fit for
decentralized lotteries and other games of chance, as well as offering
a building block for other on-chain algorithms that require
tamper-resistant pRNG.

This capability is an important component of advanced keep users, like
decentralized signing.

\subsection{Decentralized signing service}

Signing sMPC keep providers are able to sign messages, including
blockchain transactions, using a generated or provided private key.

For the first time, contracts will be able to assert their identity
off-chain, without requiring the recipient's awareness of blockchain
state.

Consider a decentralized signing service for Bitcoin transactions. The
service can participate in multi-signature transactions, only signing
transactions that follow a strict set of rules, including daily
spending limits and recipient whitelists.

Other uses for such a service include second-factor authentication,
where a contract can answer a challenge-response protocol based on
rules on the blockchain.

\subsection{Custodial wallets and cross-chain trading}

As a special case of a signing service, contracts can use keeps to
generate their own cryptocurrency wallets, taking full custody of any
received funds.

For example, a contract can generate a Bitcoin wallet, and sign
Bitcoin transactions in response to receiving assets on the contract's
native blockchain.

\subsection{Encryption service for blockchain storage}

Services like Filecoin \cite{filecoin} and Storj \cite{storj} are
being built to provide cheap, ubiquitous storage, accessible globally,
via smart contracts and traditional storage interfaces.

These services offer few privacy guarantees by default, leaving the
onus of file encryption on users. Keeps can provide a private bridge
to blockchain storage. By generating an AES key at keep initialization
and providing off-chain data access to the keep, smart contracts can
use keeps to secure files stored on decentralized services.

\subsection{Banking on public blockchains}

As more keep providers are developed, more applications that once
required a private blockchain can be built against public networks.

Traditional finance offers many examples. Consider lending, a basic
service provided by most banks.

There are a number of sensitive variables involved in the lending
process. Borrower credit scores are sensitive; risk assessment is
highly competitive; the terms of a loan aren't typically made public.

Keep providers that execute generic private smart contracts can
protect scores and the risk assessment process, while maintaining
auditability and all other benefits of a public blockchain.

\bibliographystyle{unsrt}
\bibliography{references}{}

\end{document}
